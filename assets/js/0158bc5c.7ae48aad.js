"use strict";(self.webpackChunknew_blog=self.webpackChunknew_blog||[]).push([[9448],{4031:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"open-source-intelligence/transportation/united-kingdom-vehicle-registration-search","title":"United Kingdom Vehicle Registration Search","description":"Using scripting to search through the UK vehicle system","source":"@site/docs/open-source-intelligence/transportation/united-kingdom-vehicle-registration-search.md","sourceDirName":"open-source-intelligence/transportation","slug":"/open-source-intelligence/transportation/united-kingdom-vehicle-registration-search","permalink":"/open-source-intelligence/transportation/united-kingdom-vehicle-registration-search","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"slug":"/open-source-intelligence/transportation/united-kingdom-vehicle-registration-search","description":"Using scripting to search through the UK vehicle system"},"sidebar":"tutorialSidebar","previous":{"title":"Transportation","permalink":"/category/transportation"},"next":{"title":"Red Team Operations","permalink":"/category/red-team-operations"}}');var r=i(4848),s=i(8453);const a={sidebar_position:1,slug:"/open-source-intelligence/transportation/united-kingdom-vehicle-registration-search",description:"Using scripting to search through the UK vehicle system"},o="United Kingdom Vehicle Registration Search",l={},d=[{value:"Vehicle Registration",id:"vehicle-registration",level:2},{value:"Registration Number Wildcard Search",id:"registration-number-wildcard-search",level:2},{value:"Code Limitations",id:"code-limitations",level:2},{value:"Updated Code",id:"updated-code",level:2},{value:"Source",id:"source",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"united-kingdom-vehicle-registration-search",children:"United Kingdom Vehicle Registration Search"})}),"\n",(0,r.jsx)(t.p,{children:"I recently got introduced to how vehicles are registered in the UK. I learned a lot while looking into this topic. This blog post will be a mix of two topics: a summary of how the plates are registered and a script to brute-force unknown vehicle registration numbers."}),"\n",(0,r.jsx)(t.h2,{id:"vehicle-registration",children:"Vehicle Registration"}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsx)(t.p,{children:'I will be summarizing mostly from the "Vehicle registration numbers and number plates" (INF104 Vehicle Services) PDF by the government of U.K. (Source #1)'})}),"\n",(0,r.jsx)(t.p,{children:'The "registration numbers" (which also include the letter values) are a way to identify vehicles that are owned by the Secretary of State. According to the government of U.K., "The registration number is given to the vehicle, not the registered keeper. It will stay with the vehicle (until the vehicle is broken up, destroyed or exported permanently out of the country) unless the registered keeper applies to take it off and put it on another vehicle or on to a retention certificate (V778)". The current format was introduced on September 1, 2001. It consists of:'}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["2 letter memory tag (these refer to the region in the country where a vehicle is first registered)","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'"I" (capital "i"), "Q", and "Z" are not used in local memory tags'}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"2 numbers (these tell you when it was issued)"}),"\n",(0,r.jsxs)(t.li,{children:["a space and 3 letters chosen at random","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'"Z" can be used as a random letter'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:i(4926).A+"",width:"639",height:"364"})}),"\n",(0,r.jsx)(t.p,{children:'The memory tags can tell us what region the vehicle was first registered in. Using the example above, "BD" would tell us the vehicle was registered in Birmingham. For the age, "51" would tell us it was registered between Sept 2001 and Feb 2002. The last three values are just random letters. The PDF listed in the Sources section below has a great cheat-sheet for all of the regions where this is applicable. With this information about a vehicle, as an OSINT Analyst, we can make assumptions about where an individual lives based on their vehicle registration. However, there is the possibility of a person buying a vehicle registered in another region.'}),"\n",(0,r.jsxs)(t.p,{children:["From an OSINT perspective, there will be times when information is limited or redacted, and we must make an assumption or educated guess to move the investigation further. For example, using the registration number above, imagine if we were given only the first six values:  ",(0,r.jsx)(t.code,{children:"BD51 SM"}),". We do not know the last value. Based on our research, we can assume it is an alphabetical letter between A and Z, but we cannot say which one for sure. Using code to automate this process, we can quickly generate all 26 possible values for the registration number and check those with the U.K. Driver & Vehicle Licensing Agency's database. There is a website that I had found that does this well: ",(0,r.jsx)(t.a,{href:"https://www.partialnumberplate.co.uk/",children:"https://www.partialnumberplate.co.uk/"}),". However, I did not find many other websites like this, so I decided to write my own code to automate this process."]}),"\n",(0,r.jsx)(t.h2,{id:"registration-number-wildcard-search",children:"Registration Number Wildcard Search"}),"\n",(0,r.jsx)(t.p,{children:"The code I had written works, but it definitely is not beginner-friendly. I will show the code first, then describe what it does."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'#!/usr/bin/python3\nimport string\nimport requests\nimport time\n\nAPI_key = "API_KEY_HERE" #Enter your API key here\n#format for vehicles is LLNN LLL (L=Letter; N=Number)\nfirst_letter = list(string.ascii_uppercase)\n#DVLA does not use I, Q, or Z in memory tags\nfirst_letter.remove("I")\nfirst_letter.remove("Q") #might have to remove\nfirst_letter.remove("Z")\nsecond_letter = list(string.ascii_uppercase)\nsecond_letter.remove("I")\nsecond_letter.remove("Q") #might have to remove\nsecond_letter.remove("Z")\nthird_digit = list(string.digits) # remove 3,4,8,9 as they currently cannot be possible values\nthird_digit.remove("3")\nthird_digit.remove("4")\nthird_digit.remove("8")\nthird_digit.remove("9")\nfourth_digit = list(string.digits)\nfifth_letter = list(string.ascii_uppercase)\nsixth_letter = list(string.ascii_uppercase)\nseventh_letter = list(string.ascii_uppercase)\n\n#Tracking the amount of wildcards in the plate - max 3 currently\nalphabet_wildcard = 0\nnumber_wildcard = 0\n\n# Can be used to output a list of all possible values as well - might have to dedup after \ndef full():\n    # license_plate = "@@$$@@@" #Removed space to make it easier to use with API; @ for letter, $ for number\n    # used symbols to mitigate the issue of overwriting true positive license characters\n    license_plate = "@@$$@@@" #All letters and numbers are unknown; NOT Recommended.\n    for first in first_letter:\n        for second in second_letter:\n            for third in third_digit:\n                for fourth in fourth_digit:\n                    for fifth in fifth_letter: \n                        for sixth in sixth_letter: \n                            for seventh in seventh_letter: \n                                print(license_plate.replace("@", first, 1).replace("@", second, 1).replace("$", third, 1).replace("$", fourth, 1).replace("@", fifth, 1).replace("@", sixth, 1).replace("@", seventh, 1))\n\nlicense_plate = "AA1$AAA" #Removed space to make it easier to use with API; @ for letter, $ for number\n\ndef format_check():\n    #Simple check; can be expanded to check each position, but deemed not necessary\n    if len(license_plate) != 7:\n        print("License Plate Size Incorrect")\n        exit()\n    \ndef wildcards():\n    # Using global to be able to modify the variables outside of the function\n    global alphabet_wildcard\n    global number_wildcard\n    #Search for "@" and "$" in licence plate to see how many wildcards to work off of\n    for index in license_plate:\n        if index == "@":\n            alphabet_wildcard += 1\n        if index == "$":\n            number_wildcard += 1\n\n#Cue the API to output information regarding a specific registration number\ndef license_print():\n    global alphabet_wildcard\n    global number_wildcard\n    # These do NOT account for the I,Q,Z not referenced in the memory tags - TLDR; extra output\n    if alphabet_wildcard == 1 and number_wildcard == 0:\n        for upper in list(string.ascii_uppercase):\n            print("Post request submitted for: {}".format(license_plate.replace("@", upper)))\n            api_request(license_plate.replace("@", upper))\n    elif alphabet_wildcard == 0 and number_wildcard == 1:\n        for digit in list(string.digits):\n            print("Post request submitted for: {}".format(license_plate.replace("$", digit)))\n            api_request(license_plate.replace("$", digit))\n    elif alphabet_wildcard == 1 and number_wildcard == 1:\n        for upper in list(string.ascii_uppercase):\n            for digit in list(string.digits):\n                print("Post request submitted for: {}".format(license_plate.replace("@", upper).replace("$", digit)))\n                api_request(license_plate.replace("@", upper).replace("$", digit))\n    elif alphabet_wildcard == 2 and number_wildcard == 1:\n        for first in list(string.ascii_uppercase):\n            for second in list(string.ascii_uppercase):\n                for digit in list(string.digits):\n                    print("Post request submitted for: {}".format(license_plate.replace("@", first, 1).replace("@", second,1).replace("$", digit)))\n                    api_request(license_plate.replace("@", first, 1).replace("@", second,1).replace("$", digit))\n    elif alphabet_wildcard == 1 and number_wildcard == 2:\n        for upper in list(string.ascii_uppercase):\n            for first in list(string.digits):\n                for second in list(string.digits):\n                    print("Post request submitted for: {}".format(license_plate.replace("@", upper, 1).replace("$", first,1).replace("$", second, 1)))\n                    api_request(license_plate.replace("@", upper, 1).replace("$", first,1).replace("$", second, 1))\n    elif alphabet_wildcard == 3 and number_wildcard == 0:\n        for first in list(string.ascii_uppercase):\n            for second in list(string.ascii_uppercase):\n                for third in list(string.ascii_uppercase):\n                    print("Post request submitted for: {}".format(license_plate.replace("@", first, 1).replace("@", second,1).replace("@", third, 1)))\n                    api_request(license_plate.replace("@", first, 1).replace("@", second,1).replace("@", third, 1))\n    elif alphabet_wildcard == 0 and number_wildcard == 3:\n        for first in list(string.digits):\n            for second in list(string.digits):\n                for third in list(string.digits):\n                    print("Post request submitted for: {}".format(license_plate.replace("$", first, 1).replace("$", second,1).replace("$", third, 1)))\n                    api_request(license_plate.replace("$", first, 1).replace("$", second,1).replace("$", third, 1))\n    #not working for some reason\n    else:\n        ("Currently not supported")\n        exit()\n\ndef api_request(reg_num):\n    # Actual Environment\n    #url = \'https://driver-vehicle-licensing.api.gov.uk/vehicle-enquiry/v1/vehicles\'\n    # Test Environment\n    url = \'https://uat.driver-vehicle-licensing.api.gov.uk/vehicle-enquiry/v1/vehicles\'\n    payload = "{\\n\\t\\"registrationNumber\\": \\"%(reg)s\\"\\n}" % {\'reg\': reg_num} # String interpolation with %\n    headers = {\n    \'x-api-key\': API_key,\n    \'Content-Type\': \'application/json\'\n    }\n    response = requests.request("POST", url, headers=headers, data = payload)\n    #Using print(response.text.encode(\'utf8\')) outputs lines with b\' which then needs .decode("utf-8") to fix\n    print(response.text)\n    time.sleep(2) # 2 second time out to prevent flooding\n            \nif __name__ == \'__main__\':\n    format_check()\n    #full()\n    wildcards()\n    license_print()\n'})}),"\n",(0,r.jsxs)(t.p,{children:['There are two functions that print out the registration numbers: full and license_print. The full function is disabled by default, but outputs all possible values for the registration numbers. It takes a while to output all. I kept it there as a proof of concept of how to get all of the values. license_print is there to output the registration numbers based on wildcards. In the code, I use "$" for a numerical wildcard, and a "@" for an alphabetical wildcard. ',(0,r.jsx)(t.strong,{children:"The code will not work as expected until you put in an API key at the top."})," I requested an API key from the DVLA (currently located at: ",(0,r.jsx)(t.a,{href:"https://register-for-ves.driver-vehicle-licensing.api.gov.uk/",children:"https://register-for-ves.driver-vehicle-licensing.api.gov.uk/"}),") and got the key overnight. Keep in mind, the more alphabetical wildcards there are, the more output there will be. ",(0,r.jsx)(t.strong,{children:"The code currently is set up to query the test API, so un-comment the regular API to query actual data. You will then have to comment out the test API line."}),' Below is output I got from the test API. I know the value of "AA19AAA" would give me a result, so I made the position of the "9" to be the wildcard: ',(0,r.jsx)(t.code,{children:"AA1$AAA"}),". This wildcard would go from ",(0,r.jsx)(t.code,{children:"AA11AAA"})," to ",(0,r.jsx)(t.code,{children:"AA19AAA"}),". We can see this in the following output of the code:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-json",children:'Post request submitted for: AA10AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA11AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA12AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA13AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA14AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA15AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA16AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA17AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA18AAA\n{"errors":[{"status":"404","code":"404","title":"Vehicle Not Found","detail":"Record for vehicle not found"}]}\nPost request submitted for: AA19AAA\n{"registrationNumber":"AA19AAA","artEndDate":"2025-03-30","co2Emissions":300,"engineCapacity":2000,"euroStatus":"EURO1","markedForExport":false,"fuelType":"PETROL","motStatus":"No details held by DVLA","revenueWeight":0,"colour":"RED","make":"FORD","typeApproval":"M1","yearOfManufacture":2019,"taxDueDate":"2024-07-31","taxStatus":"Taxed","dateOfLastV5CIssued":"2019-05-20","wheelplan":"2 AXLE RIGID BODY","monthOfFirstDvlaRegistration":"2019-03","monthOfFirstRegistration":"2019-03","realDrivingEmissions":"1"}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["If you want to use ",(0,r.jsx)(t.code,{children:"jq"})," to make the output look much cleaner, you can remove the print statements. There are a lot of guardrails I contemplated on including in this code. If I was to include the guardrails for the positions of the wildcards to be correct and making dictionaries for all combinations of the first two letters, that would end up taking a lot of lines of code. I do have that at the back of mind, and might consider it, if time and interest permits."]}),"\n",(0,r.jsx)(t.h2,{id:"code-limitations",children:"Code Limitations"}),"\n",(0,r.jsx)(t.p,{children:'The code is limited to 3 wildcards. I felt like any more than 3 wildcards, and you are just brute-forcing a government portal without any actual direction of what you are looking for. My code is a bit on the greedier side. It outputs more than is needed. In instances where a wildcard is one of the first 2 letters, it would print out all letters from A-Z, without excluding the letters not used: "I", "Q", "Z". If I ever do a revisit to this code, or a redo, I plan on making it exclude those values and be able to be more precise in the output. My goal was to make a code that just works. I was not able to find many resources that did just this, so I decided to make code that .... well, just works.'}),"\n",(0,r.jsx)(t.h2,{id:"updated-code",children:"Updated Code"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'# Import modules\nimport requests\nimport time\nimport sys\nimport string\nimport argparse\nimport signal # To catch the KeyboardInterrupt when CTRL-C is run\n\n#Parsing the command-line arguments\nparser = argparse.ArgumentParser(\n                    prog=\'licenseV2.py\',\n                    description=\'This code uses UK partial plates to convert that into potential plates. It then searches the DVLA API with that information.\',\n                    epilog=\'Created by: Haris Qazi. Assisted by: AccessOSINT.\')\nparser.add_argument("license", type=str)\nparser.add_argument(\'--api\', help=\'Use API Key. If no key is provided, it will not search DVLA database.\') \nargs = parser.parse_args()\n# Plate Values\nmemory_tag =  list(string.ascii_uppercase)\nmemory_tag.remove("I")\nmemory_tag.remove("Q")\nmemory_tag.remove("Z")\nthird_number = ("0", "1", "2", "5", "6", "7")\n# fourth number is done in the loops themselves\nrandom_letter = list(string.ascii_uppercase)\nrandom_letter.remove("I")\nrandom_letter.remove("Q")\n\n# The following follow a "waterfall effect". wildcards_plates -> wildcard_plates -> plates. The wildcard plates get placed on the top and then one by one the wildcards are removed.\nwildcards_plates = [] # 3 wildcards -> which turn to 2\nwildcard_plates = [] # 2 wildcards -> which turn to 1\nplates = [] # Completed List; 1, which turn to 0\n# Command Line Input\npartial = args.license.upper().replace(" ", "")\n# Gets the indexes of where wildcard characters are.\n# uses list compression\nindices = [i for i, char in enumerate(partial) if char == \'?\']\n#count the amount of wildcards\nwildcard = len(indices)\n# Check\nif args.license == "":\n    print("No argument provided")\n    exit()\nelif len(partial) != 7:\n    print("Size Incorrect")\n    exit()\nelif "?" not in partial:\n    print("No Wildcards found")\n    exit()\nelif wildcard > 3 or wildcard < 1:\n    print("Only 1 - 3 Wildcards Allowed")\n    exit()\n# ---------------------------------------------------------------------------------------------\ndef one_wildcard():\n# Works for ?D51AAA and B?51AAA\n    if indices[0] < 2:\n        for letter in memory_tag:\n            wildcards_plates.append(partial.replace("?", letter, 1))\n    # BD?1AAA\n    elif indices[0] == 2:\n        for number in third_number:\n            wildcards_plates.append(partial.replace("?", number, 1))\n\n    # BD5?AAA\n    elif indices[0] == 3:\n        if partial[2] == "0":\n            for number in range(2, 10):\n                wildcards_plates.append(partial.replace("?", str(number), 1))\n        elif partial[2] == "2" or partial[2] == "7":\n            for number in range(1, 4): #Until February 2024\n                wildcards_plates.append(partial.replace("?", number, 1))\n        else:\n            for number in list(string.digits): #could have done a set, but would be overkill\n                wildcards_plates.append(partial.replace("?", number, 1))\n    # BD51?AA and BD51A?A and BD51AA?\n    elif indices[0] > 3:\n        for letter in random_letter:\n            wildcards_plates.append(partial.replace("?", letter, 1))\n# ---------------------------------------------------------------------------------------------\ndef two_wildcards():\n    for p in wildcards_plates:\n        if indices[1] < 2:\n            for letters in memory_tag:\n                #print(p.replace("?", letters))\n                wildcard_plates.append(p.replace("?", letters, 1))\n        # BD?1AAA\n        elif indices[1] == 2:\n            for number in third_number:\n                wildcard_plates.append(p.replace("?", number, 1))\n        elif indices[1] == 3:\n            if p[2] == "0":\n                for number in range(2, 10):\n                    wildcard_plates.append(p.replace("?", str(number), 1))\n            elif p[2] == "2" or p[2] == "7":\n                for number in range(1, 4): #Until February 2024\n                    wildcard_plates.append(p.replace("?", str(number), 1))\n            else:\n                for number in list(string.digits): #could have done a set, but would be overkill\n                    wildcard_plates.append(p.replace("?", number, 1))\n        else:\n            for letter in random_letter:\n                wildcard_plates.append(p.replace("?", letter, 1))\n# ---------------------------------------------------------------------------------------------\ndef three_wildcards():\n    for p in wildcard_plates:\n        if indices[2] < 2:\n            for letters in memory_tag:\n                #print(p.replace("?", letters))\n                plates.append(p.replace("?", letters, 1))\n        elif indices[2] == 2:\n            for number in third_number:\n                plates.append(p.replace("?", number, 1))\n        elif indices[2] == 3:\n            if p[2] == "0":\n                for number in range(2, 10):\n                    plates.append(p.replace("?", str(number), 1))\n            elif p[2] == "2" or p[2] == "7":\n                for number in range(1, 4): #Until February 2024\n                    plates.append(p.replace("?", str(number), 1))\n            else:\n                for number in list(string.digits): #could have done a set, but would be overkill\n                    plates.append(p.replace("?", number, 1))\n        else:\n            for letter in random_letter:\n                plates.append(p.replace("?", letter, 1))        \n# ---------------------------------------------------------------------------------------------\ndef api_request(reg_num):\n    # Actual Environment\n    #url = \'https://driver-vehicle-licensing.api.gov.uk/vehicle-enquiry/v1/vehicles\'\n    # Test Environment\n    url = \'https://uat.driver-vehicle-licensing.api.gov.uk/vehicle-enquiry/v1/vehicles\'\n    payload = "{\\n\\t\\"registrationNumber\\": \\"%(reg)s\\"\\n}" % {\'reg\': reg_num} # String interpolation with %\n    headers = {\n    \'x-api-key\': args.api, #using the argument for --api\n    \'Content-Type\': \'application/json\'\n    }\n    response = requests.request("POST", url, headers=headers, data = payload)\n    #Using print(response.text.encode(\'utf8\')) outputs lines with b\' which then needs .decode("utf-8") to fix\n    print(response.text)\n    #time.sleep(2) # 2 second time out to prevent flooding\n# ---------------------------------------------------------------------------------------------\n# Not Needed - felt like it would make the output clean\ndef sigint_handler(signal, frame):\n    print (\'KeyboardInterrupt Error Caught\')\n    sys.exit(0)\n\ndef main():\n    global plates\n    signal.signal(signal.SIGINT, sigint_handler)\n    if wildcard == 1:\n        one_wildcard()\n        plates = wildcards_plates\n    elif wildcard == 2:\n        one_wildcard()\n        two_wildcards()\n        plates = wildcard_plates\n    else:\n        one_wildcard()\n        two_wildcards()\n        three_wildcards()\n        #plates = * not needed, as we are writing to plates variable directly\n    # Check if API key is provided here\n    if args.api is not None:\n        for plate in plates:\n            api_request(plate)\n    else:\n        for plate in plates:\n            print(plate)\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,r.jsxs)(t.p,{children:["To run the code, simply run ",(0,r.jsx)(t.code,{children:'python3 licenseV2.py "license_plate"'}),", where you replace the string with the partial plate with the wildcard ",(0,r.jsx)(t.code,{children:"?"}),". An example of this would be ",(0,r.jsx)(t.code,{children:'python3 licenseV2.py "AA1?AAA"'})," on Linux. This would output all possibilites for the 4th value. If you have an API key and would like to use it, use the ",(0,r.jsx)(t.code,{children:"--api"})," argument and provide the key in quotes after that, such as: ",(0,r.jsx)(t.code,{children:'python3 licenseV2.py "AA1?AAA" --api "ThisIsMyAPIKey"'}),". If the key is provided, the DVLA API will be queried. If not, the plates will be printed out."]}),"\n",(0,r.jsx)(t.p,{children:"Here are the following changes updated in this version of the code:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Replacing the wildcard from ",(0,r.jsx)(t.code,{children:"$"})," and ",(0,r.jsx)(t.code,{children:"@"})," to just ",(0,r.jsx)(t.code,{children:"?"})]}),"\n",(0,r.jsx)(t.li,{children:"Command line arguments for the registration number and the API key"}),"\n",(0,r.jsxs)(t.li,{children:["Adding ",(0,r.jsx)(t.code,{children:"--help"})," information to guide users"]}),"\n",(0,r.jsx)(t.li,{children:"Changing the code from the ground up"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"source",children:"Source"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/1068365/inf104-vehicle-registration-numbers-and-number-plates.pdf",children:"https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/1068365/inf104-vehicle-registration-numbers-and-number-plates.pdf"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://developer-portal.driver-vehicle-licensing.api.gov.uk/apis/vehicle-enquiry-service/code-examples.html#nodejs-using-axios",children:"https://developer-portal.driver-vehicle-licensing.api.gov.uk/apis/vehicle-enquiry-service/code-examples.html#nodejs-using-axios"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://developer-portal.driver-vehicle-licensing.api.gov.uk/apis/vehicle-enquiry-service/vehicle-enquiry-service-description.html#vehicle-enquiry-service-ves-api-guide",children:"https://developer-portal.driver-vehicle-licensing.api.gov.uk/apis/vehicle-enquiry-service/vehicle-enquiry-service-description.html#vehicle-enquiry-service-ves-api-guide"})}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Vehicle_registration_plates_of_the_United_Kingdom",children:"https://en.wikipedia.org/wiki/Vehicle_registration_plates_of_the_United_Kingdom"})," (didn't use this source too much, but is a great summary of the topic)"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},4926:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/image1111111-4fe73ca8fdd341db7d4202222a27477f.png"},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(6540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);