"use strict";(self.webpackChunknew_blog=self.webpackChunknew_blog||[]).push([[5215],{1033:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"open-source-intelligence/breach-data/containerization","title":"Containerization","description":"Discussing using containers for breach data infrastructure","source":"@site/docs/open-source-intelligence/breach-data/containerization.md","sourceDirName":"open-source-intelligence/breach-data","slug":"/open-source-intelligence/breach-data/containerization","permalink":"/open-source-intelligence/breach-data/containerization","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"slug":"/open-source-intelligence/breach-data/containerization","description":"Discussing using containers for breach data infrastructure"},"sidebar":"tutorialSidebar","previous":{"title":"Stealer Logs","permalink":"/open-source-intelligence/breach-data/stealer-logs"},"next":{"title":"Transportation","permalink":"/category/transportation"}}');var a=t(4848),i=t(8453);const s={sidebar_position:5,slug:"/open-source-intelligence/breach-data/containerization",description:"Discussing using containers for breach data infrastructure"},r="Containerization",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Virtual Machines",id:"virtual-machines",level:2},{value:"Operating System (OS) Recommendations",id:"operating-system-os-recommendations",level:3},{value:"Debian (Novice)",id:"debian-novice",level:4},{value:"Fedora Silverblue (Advanced Beginner)",id:"fedora-silverblue-advanced-beginner",level:4},{value:"Scripting with Bash and Ansible",id:"scripting-with-bash-and-ansible",level:3},{value:"Bash",id:"bash",level:4},{value:"Ansible",id:"ansible",level:4},{value:"VM Escape",id:"vm-escape",level:3},{value:"Podman",id:"podman",level:2},{value:"Apache Solr",id:"apache-solr",level:3},{value:"MicroK8s (Kubernetes)",id:"microk8s-kubernetes",level:2},{value:"Apache Solr",id:"apache-solr-1",level:3},{value:"PersistentVolume",id:"persistentvolume",level:4},{value:"PersistentVolumeClaim",id:"persistentvolumeclaim",level:4},{value:"Deployment",id:"deployment",level:4},{value:"Load Balancing",id:"load-balancing",level:4},{value:"All YAML combined (will not work)",id:"all-yaml-combined-will-not-work",level:4},{value:"Executing Commands on Multiple Pods",id:"executing-commands-on-multiple-pods",level:4},{value:"Setup",id:"setup",level:4},{value:"General Recommendations",id:"general-recommendations",level:2},{value:"Errors",id:"errors",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Sources",id:"sources",level:2}];function h(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"containerization",children:"Containerization"})}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["I have seen application containerization solutions mentioned for a while now, and I wanted to look into a couple of these solutions to be used for breach infrastructure, especially for breach data indexing (Apache Solr). From an outside perspective, it seems like a good way to have lightweight systems that allow for scaling up if required. The title, however, alludes to containerizing solutions in general, which I will use as an umbrella term to include virtual machines as well. ",(0,a.jsx)(n.strong,{children:"I will be basing this blog on a Linux OS, but the tools will work on Windows and macOS as well."})]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"My testing environment for this blog was a Debian 12 virtual machine hosted on VirtualBox. It has 50GB of storage, 6000MB RAM, and 3 cores."})}),"\n",(0,a.jsx)(n.p,{children:"This blog will discuss 3 different solutions:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Virtual Machines"}),"\n",(0,a.jsx)(n.li,{children:"Podman (similar to Docker)"}),"\n",(0,a.jsx)(n.li,{children:"MicroK8s (Kubernetes, which is similar to Docker Swarm)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"virtual-machines",children:"Virtual Machines"}),"\n",(0,a.jsx)(n.p,{children:"When it comes to virtual machines, there are two main types of hypervisors: Type 1 (VMware ESXi, Microsoft Hyper-V, KVM) and Type 2 (Oracle VM VirtualBox, VMware Workstation, Microsoft Virtual PC). I would highly recommend planning your breach data environment prior to choosing a type of hypervisor because as your data and environment changes, it becomes a bit more tedious to move from one type to another. As such, I would recommend Type 2 for hobbyists, while for organizations, I would recommend Type 1. There are a lot of online tutorials that discuss the benefits of Type 1 in comparison to Type 2 and vice versa, so I will not discuss those here. In this section, I will discuss the following:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Operating System (OS) Recommendations"}),"\n",(0,a.jsx)(n.li,{children:"Scripting with Bash and Ansible"}),"\n",(0,a.jsx)(n.li,{children:"VM Escape"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Virtual machines are great for having a separate and virtual system that allows for segmenting your project from the host OS. As you download different types of breaches, there is always a possibility for a file to be infected with malware. Having a separate system allows us to mitigate this situation with a high percentage of success rate. The steps for setting up a VM has been discussed a lot online, so I chose not to include it here. However, the steps should be similar to what is listed here: ",(0,a.jsx)(n.a,{href:"https://linuxsimply.com/linux-basics/os-installation/virtual-machine/debian-on-virtualbox/",children:"https://linuxsimply.com/linux-basics/os-installation/virtual-machine/debian-on-virtualbox/"}),". The steps to download Solr are in the docs: ",(0,a.jsx)(n.a,{href:"https://solr.apache.org/guide/solr/latest/deployment-guide/installing-solr.html",children:"https://solr.apache.org/guide/solr/latest/deployment-guide/installing-solr.html"}),". These are the steps I use when downloading Solr from source."]}),"\n",(0,a.jsx)(n.h3,{id:"operating-system-os-recommendations",children:"Operating System (OS) Recommendations"}),"\n",(0,a.jsx)(n.p,{children:"When it comes to OSes to put on a virtual machine, I always recommend Linux (Debian-based) as it is the most flexible for most things (excluding video games). You have a package manager at your fingertips that allows for easy access to download your applications. The OS itself is lighter in weight compared to macOS and Windows. You do have to apply security and privacy hardening on Linux for it to be secure and private, but due to its less bloated system, it is easier to do. There is minimal OS telemetry. It is highly customizable. However, all of this comes at a learning curve, which is not steep (but definitely can get steep for things like OS hardening, compilation flags, etc.). With that being said, when it comes to breach data environments, as of writing this blog (July 2024), I would recommend the following Linux OSes at what I would consider different Linux learning tiers:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Debian (Novice)","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Kicksecure"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"Fedora Silverblue (Advanced Beginner)"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"debian-novice",children:"Debian (Novice)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://www.debian.org/",children:"Debian"})," is an entry-level operating system in the Linux ecosystem, although some consider Linux Mint to be that. Linux Mint (and Ubuntu) is based on Debian. I recommend this OS as the installation method for this OS and using the OS out of the box is really easy. You simply follow the installation prompts and the OS is good to go. For installing packages, the `apt` package manager gives you most tools, and Flatpak and Snap managers are one command away to be installed. There is a lot of tutorials and documentation for Debian in case one gets stuck, which is why I have this listed at the Novice level. If you get comfortable with Debian by itself, I highly recommend moving on to ",(0,a.jsx)(n.a,{href:"https://www.kicksecure.com/",children:"Kicksecure"}),", which is hardened Debian."]}),"\n",(0,a.jsx)(n.h4,{id:"fedora-silverblue-advanced-beginner",children:"Fedora Silverblue (Advanced Beginner)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://fedoraproject.org/atomic-desktops/silverblue/",children:"Fedora Silverblue"})," is a semi-rolling release Fedora-based atomic/immutable distribution. I mention this in my blog due to my strong belief in having backups, which is what the atomic/immutable aspect of it allows you to have. When updating your system, if it fails, and your OS gets mis-configured, you can roll the OS back to a previous snapshot. This way you will always have a working OS. Working with breach data and setting up the infrastructure takes time, and in my opinion, having a backup, even at the OS-level, is needed. Silverblue also uses ",(0,a.jsx)(n.a,{href:"https://containertoolbx.org/",children:"Toolbx"}),", which allows you to segment projects on your system. This would allow you to try other configurations on another project, without it affecting your main working project. Silverblue uses GNOME as the desktop, however if you prefer KDE, Sway, or Budgie, check out the other variants: ",(0,a.jsx)(n.a,{href:"https://fedoraproject.org/atomic-desktops/",children:"https://fedoraproject.org/atomic-desktops/"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"scripting-with-bash-and-ansible",children:"Scripting with Bash and Ansible"}),"\n",(0,a.jsx)(n.p,{children:"Once the OS is setup, there are automated and repeatable ways to configure your environment. I have had great success with both Bash and Ansible, so I will be mentioning these here. In terms of automation of breach data infrastructure, I would recommend having a script/playbook that does the following:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Updates and upgrades the system"}),"\n",(0,a.jsx)(n.li,{children:"Updates and upgrades the packages/applications"}),"\n",(0,a.jsx)(n.li,{children:"Installs applications from package managers (Apt packages, Flatpaks, Snaps, etc.)"}),"\n",(0,a.jsx)(n.li,{children:"Installs apps from source (GitHub, GitLab, etc.)"}),"\n",(0,a.jsx)(n.li,{children:"Downloads and/or edits any configuration files"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"An example of this can be the following:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Updating and upgrading the system using apt"}),"\n",(0,a.jsx)(n.li,{children:"Installing ripgrep using apt"}),"\n",(0,a.jsx)(n.li,{children:"Downloading and Installing Apache Solr from source"}),"\n",(0,a.jsx)(n.li,{children:"Editing Solr configuration files based on your requirements"}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"I, unfortunately, do not have any Bash scripts or Ansible playbooks that are specifically for breach data. If I end up working on those and if I remember to, I will update this blog with that information."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"bash",children:"Bash"}),"\n",(0,a.jsx)(n.p,{children:"Bash is a command interpreter and a programming language for Linux [2]. Scripts can be written to automate command execution on your system. For example, if you want to have the same configuration on multiple machines, you would use Bash. See the following as an example to what a script can look like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'#!/usr/bin/env bash \n#Shebang line that tells the system what interpreter to use \n\n#Environment variables\nnon_root_user="user"\nHOME="/home/$non_root_user"\ndownloads_directory="$HOME/Downloads"\n\n#Example list\napt_package_list=(\n    akregator\n    apt-transport-https\n    bleachbit\n    btop\n    wget\n    zsh\n)\n\n#Example function\ninstall_apt_packages() {\n    apt update -y && apt upgrade -y\n    for package in "${apt_package_list[@]}"; do\n        echo "Installing Apt Package: $package"\n        apt install -y $package\n    done\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Scripting like this allows for repeated customization of your system. Simply have the script on the machine, and run it. This will go line by line and execute the commands on your system. This is great for having a running document (script) that you can rely on to set up your system. Although Bash is good for basic tasks, I would recommend Ansible more, as it has validation built into it, notifying you when errors are found."}),"\n",(0,a.jsx)(n.h4,{id:"ansible",children:"Ansible"}),"\n",(0,a.jsxs)(n.p,{children:["Ansible is an IT automation software that allows you to create playbooks dictating what you want the end result to look like. Think of playbooks as a script (playbook) that calls multiple functions (tasks) in order to get a job done. Compared to Bash, Ansible does have a learning curve to it. I have written a ",(0,a.jsx)(n.a,{href:"https://github.com/harisqazi1/ansible/blob/main/ansible_cheatsheet.md",children:"cheatsheet"}),", that is meant to speed-run the learning process a bit. I won't be mentioning all of the features of Ansible here, as it might go off of the scope of this blog a bit. The only feature worth mentioning is that it allows you to have a playbook, which repeats the same setup on all the systems, allowing systems to be the same in configuration. In addition, it works off of the end result, so it makes sure the specific change is made before it moves on to the next item. This is great for enterprise environments, but I would recommend it for personal use as well. I would recommend reading the ",(0,a.jsx)(n.a,{href:"https://docs.ansible.com/ansible/latest/getting_started/index.html",children:"Ansible Docs"})," as a starting point to catch up to speed on the technology and its benefits. If you wanted a playbook template to edit and use, I have a couple as well: ",(0,a.jsx)(n.a,{href:"https://github.com/harisqazi1/ansible",children:"https://github.com/harisqazi1/ansible"}),"."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"TLDR: Think of a Bash script natively as UDP, while an Ansible playbook as TCP. Ansible checks to make sure commands are executed properly and the output is as expected, while bash natively does not."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"vm-escape",children:"VM Escape"}),"\n",(0,a.jsxs)(n.p,{children:["Breach data comes in various formats, such as SQL dumps, text files, or in an archival formats (.7z, .zip, etc.). It is definitely possible that any of these could contain not only malware, but malware that exploits vulnerabilities in the VM in order to escape the environment (see: ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Virtual_machine_escape",children:"https://en.wikipedia.org/wiki/Virtual_machine_escape"}),"). As such, defense in depth is a model that is important to keep in mind when dealing with anything security related. In order to be safe when dealing with breach data, I do the following:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'Check the file extensions to make sure it isn\'t anything suspicious. No breach file should have a ".exe" extension. It is breach data, not a cracked video game'}),"\n",(0,a.jsx)(n.li,{children:"Run `head filename`. This allows you to see the first 10 lines of the file. You can then verify if this is an executable file or breach data"}),"\n",(0,a.jsxs)(n.li,{children:["If you are still uncertain, you can grab the SHA256 or MD5 hashes of the file and upload them to ",(0,a.jsx)(n.a,{href:"https://www.virustotal.com/gui/home/upload",children:"VirusTotal"}),". Of course, you can also use ",(0,a.jsx)(n.a,{href:"https://www.clamav.net/",children:"ClamAV"})," to check this first. ",(0,a.jsx)(n.strong,{children:"NOTE: MD5 and SHA-1 are known to have hash-collisions, so be cautious of this."})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"podman",children:"Podman"}),"\n",(0,a.jsxs)(n.p,{children:["I was thinking of mentioning Docker here. However, I personally use ",(0,a.jsx)(n.a,{href:"https://podman.io/",children:"Podman"}),'. The reasoning is simple: "Podman stands out from other container engines because it\u2019s daemonless, meaning it doesn\'t rely on a process with root privileges to run containers"[3]. It would be unfair for me to discuss Docker, when I myself do not use it or plan to use it. Most of the commands that work for Podman, should work for Docker as well (You will have to change ',(0,a.jsx)(n.code,{children:"podman"})," to ",(0,a.jsx)(n.code,{children:"docker"})," in your commands. If the aforementioned root-less architecture is a risk-accepted for you in relation to a little higher learning curve, feel free to use Docker as there is more support and documentation for it. The goal isn't to push an individual to use a specific solution, but to use a specific technology for their needs."]}),"\n",(0,a.jsx)(n.h3,{id:"apache-solr",children:"Apache Solr"}),"\n",(0,a.jsxs)(n.p,{children:["The following will be a list of commands you can use to get Apache Solr up and running. (",(0,a.jsx)(n.strong,{children:"This is not a script"}),", but could easily be modified into one - if your file paths match with what the script has):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# Update and upgrade your system to the newest packages\nsudo apt update && sudo apt upgrade\n# Install Podman\nsudo apt -y install podman\n# Pull Solr from the Docker repository\npodman pull docker.io/solr\n# Creating a container called solr_breach\npodman run -d -p 8983:8983 --name solr_breach solr\n# Check to see if container is running\npodman container list\n# Create a breach core\npodman exec -it solr_breach bin/solr create_core -c breach\n# Make a directory you will connect to the container\nmkdir solr_local\n# Post (send) the data to Solr; $PWD = "/home/[user]/Downloads/solr_local"\npodman run --rm -v "$PWD:/mydata" --network=host solr bin/solr post -c breach /mydata/soletrade-users.txt.json\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Just like that, you have Apache Solr setup and ready to go in a containerized environment. It should be available at ",(0,a.jsx)(n.code,{children:"http://localhost:8983"})," The following commands are just for maintenance:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Remove container\npodman stop solr_breach\npodman rm solr_breach\n# Restart container after stopping it\npodman start solr_breach\n# Deleting all documents in a core\n## Go to http://0.0.0.0:8983/solr/#/breach/documents\n## change document type to XML\n## Add the following under Document(s):\n<delete> \n   <query>*:*</query> \n</delete>\n## Hit Submit Button\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you wanted to go with another container, you would just pull it. You could, of course, create your own Dockerfile (which Podman can read), if you want to set up a custom breach system. Maybe you have a custom app you built for breach data. In that case, using a Dockerfile would be great for you to set your environment up as a container. If you wanted to connect multiple containers, you can look into ",(0,a.jsx)(n.a,{href:"https://docs.docker.com/compose/",children:"Docker Compose"})," as well. The popular service ",(0,a.jsx)(n.code,{children:"search.0t.rocks"})," was using exactly this: ",(0,a.jsx)(n.a,{href:"https://github.com/MiyakoYakota/search.0t.rocks/blob/main/docker-compose.yml",children:"https://github.com/MiyakoYakota/search.0t.rocks/blob/main/docker-compose.yml"}),". If you did want to learn docker, the following link has some great places to start: ",(0,a.jsx)(n.a,{href:"https://github.com/veggiemonk/awesome-docker?tab=readme-ov-file#where-to-start",children:"https://github.com/veggiemonk/awesome-docker?tab=readme-ov-file#where-to-start"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"microk8s-kubernetes",children:"MicroK8s (Kubernetes)"}),"\n",(0,a.jsx)(n.p,{children:"Kubernetes is similar to Docker Swarm, in that both solutions allow you to scale your container up to scale for demand. This works well for high-demand systems, where resource intensive tasks are conducted. Think of Kubernetes as a way to replicate an image to multiple Podman containers, and scale it up to balance your workload."}),"\n",(0,a.jsx)(n.p,{children:"So why MicroK8s? I can only test on the hardware / software that I do have. Kubernetes (and Docker Swarm) relies on having multiple machines where you can create multiple nodes to work simultaneously. Can I setup a network of VMs running simultaneously to create this network of machines? I can. Do I have the resources for that on my machine? Not at this moment. The good thing is that the similar to how Kubernetes is meant for multiple machines, MicroK8s allows you to do all that work on a small scale on one machine [5][6]. Since the commands are similar for both, this should not be a problem when setting up a bigger system."}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"I will mention MicroK8s and Kubernetes interchangeably going forward. Just understand that MicroK8s is running Kubernetes at a small scale, so it essentially is Kubernetes."})}),"\n",(0,a.jsx)(n.h3,{id:"apache-solr-1",children:"Apache Solr"}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Apache Solr has a dedicated page for setting Solr up with Kubernetes (Apache Solr Operator) leveraging Helm and it uses Zookeeper for load balancing. I wanted to leverage a container image and work off of that for this blog. However, if you want to try their method, feel free to check out the dedicated page: ",(0,a.jsx)(n.a,{href:"https://solr.apache.org/operator/",children:"https://solr.apache.org/operator/"})]})}),"\n",(0,a.jsxs)(n.p,{children:["Create the following files first, so that way you can run the commands back to back. On Linux, you can install gedit (",(0,a.jsx)(n.code,{children:"sudo apt install gedit -y"}),") or use the command line editor like ",(0,a.jsx)(n.code,{children:"nano"})," or ",(0,a.jsx)(n.code,{children:"vim"})," to edit files. I would recommend creating a folder (",(0,a.jsx)(n.code,{children:"mkdir breach-YAML"}),") where you can store the following files. This makes deployment much easier, since we can point Kubernetes to read a folder instead of 4 different files."]}),"\n",(0,a.jsx)(n.h4,{id:"persistentvolume",children:"PersistentVolume"}),"\n",(0,a.jsx)(n.p,{children:"We will start off by creating a persistent volume. This will allow us to create a volume location on our local machine that Kubernetes via MicroK8s will recognize."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",metastring:'title="breach-pv.yaml"',children:"apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: solr-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadOnlyMany\n  hostPath:\n    path: /mnt/test\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["In my testing, instead of ",(0,a.jsx)(n.code,{children:"/mnt/test/"}),' Kubernetes mounted to a sub-folder where snap applications store their files. To mitigate this, I went into a pod (after the infrastructure was up and running; after deployment) and then created a file called "hello.txt" in ',(0,a.jsx)(n.code,{children:"/opt/solr/server/solr/mydata"}),". I then ran ",(0,a.jsx)(n.code,{children:'find / -iname "hello.txt"'})," on my local machine, to see where this file was created. That will be the location you will need to upload your breach data to, for it to be readable by Kubernetes."]})}),"\n",(0,a.jsx)(n.h4,{id:"persistentvolumeclaim",children:"PersistentVolumeClaim"}),"\n",(0,a.jsx)(n.p,{children:'We then create a persistent volume claim. This allows each pod to "request" a capacity from the persistent volume. NOTE: The persistent volume claim cannot exceed the storage size of the persistent volume. Ex: If you have 10Gi storage capacity in the volume, keep the storage <= 10Gi in the volume claim.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",metastring:'title="breach-pvc.yaml"',children:"apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: solr-pvc\nspec:\n  accessModes:\n    - ReadOnlyMany\n  resources:\n    requests:\n      storage: 10Gi\n"})}),"\n",(0,a.jsxs)(n.p,{children:["I initially chose the access mode to be ",(0,a.jsx)(n.code,{children:"ReadWriteMany"}),'. This means "the volume can be mounted as read-write by many nodes" [16].  ',(0,a.jsx)(n.strong,{children:"However, on reading this portion of the blog again and reviewing my work, I would recommend"})," ",(0,a.jsx)(n.code,{children:"ReadOnlyMany"}),' - "the volume can be mounted as read-only by many nodes" [16]. As of July 10, the code above reflects "ReadOnlyMany". I believe that the nodes should only be able to read the breach data and not be able to write to the volume. If you believe otherwise, feel free to use "ReadWriteMany".']}),"\n",(0,a.jsx)(n.h4,{id:"deployment",children:"Deployment"}),"\n",(0,a.jsx)(n.p,{children:"This is the main file where we mention the image we plan to use: Apache Solr. In this file, you also connect the persistent volume claim to the image. This way you can connect your host to the pods without having to run additional commands."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",metastring:'title="breach-deployment.yaml"',children:"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: solr-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: solr\n  template:\n    metadata:\n      labels:\n        app: solr\n    spec:\n      containers:\n        - name: solr\n          image: solr:latest\n          ports:\n            - containerPort: 8983\n          volumeMounts:\n            - mountPath: /opt/solr/server/solr/mydata\n              name: solr-storage\n      volumes:\n        - name: solr-storage\n          persistentVolumeClaim:\n            claimName: solr-pvc\n"})}),"\n",(0,a.jsx)(n.h4,{id:"load-balancing",children:"Load Balancing"}),"\n",(0,a.jsx)(n.p,{children:"The last part we need, is to load balance our setup. If this ends up getting big to the point where multiple teams need to access breach data quickly, we need to have a way to provide for all of those users without having them visit another endpoint."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",metastring:'title="breach-service.yaml"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: solr-service\nspec:\n  selector:\n    app: solr\n  ports:\n    - protocol: TCP\n      port: 8983\n      targetPort: 8983\n  type: LoadBalancer\n"})}),"\n",(0,a.jsx)(n.h4,{id:"all-yaml-combined-will-not-work",children:"All YAML combined (will not work)"}),"\n",(0,a.jsxs)(n.p,{children:["I have combined all of the YAML information into one file and this ",(0,a.jsx)(n.strong,{children:"did not work"}),". Kubernetes only ran 1/4 YAML configs in the one large file, thus it needs to be broken down into separate files. However, if you just wanted all the configs in one location, see the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"---\n# breach-pv.yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: solr-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadOnlyMany\n  hostPath:\n    path: /mnt/test\n    \n# breach-pvc.yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: solr-pvc\nspec:\n  accessModes:\n    - ReadOnlyMany\n  resources:\n    requests:\n      storage: 10Gi\n\n# breach-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: solr-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: solr\n  template:\n    metadata:\n      labels:\n        app: solr\n    spec:\n      containers:\n        - name: solr\n          image: solr:latest\n          ports:\n            - containerPort: 8983\n          volumeMounts:\n            - mountPath: /opt/solr/server/solr/mydata\n              name: solr-storage\n      volumes:\n        - name: solr-storage\n          persistentVolumeClaim:\n            claimName: solr-pvc\n\n# breach-service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: solr-service\nspec:\n  selector:\n    app: solr\n  ports:\n    - protocol: TCP\n      port: 8983\n      targetPort: 8983\n  type: LoadBalancer\n"})}),"\n",(0,a.jsx)(n.h4,{id:"executing-commands-on-multiple-pods",children:"Executing Commands on Multiple Pods"}),"\n",(0,a.jsxs)(n.p,{children:["While working on this project, I did not find a way to run commands on multiple pods. Yes, there are ways to output YAML files of container configurations, but not what is in the container itself. For example, if I created a core (index) in Apache Solr on a pod and then pushed data to it, the other nodes would not have this change. See the following images as an example of what happens when I go to query that indexed data (indexed data is dummy data from ",(0,a.jsx)(n.a,{href:"https://mockaroo.com/",children:"https://mockaroo.com/"}),") :"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(6171).A+"",width:"1399",height:"940"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(7700).A+"",width:"1398",height:"427"})}),"\n",(0,a.jsx)(n.p,{children:"The IP Address is for the load balancer, but since only one pod has the information and the others don't, we start getting errors when it starts to query other nodes. To mitigate, I used the following shell script."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"script.sh"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n\n# Get the list of pod names\nPODS=$(microk8s kubectl get pods -l app=solr -o jsonpath=\'{.items[*].metadata.name}\')\n\n# Loop through each pod and run the command\nfor POD in $PODS; do\n  echo "Running command on pod: $POD"\n  microk8s kubectl exec $POD -- $1 #The command line first argument\n  ## For longer commands put it in between a \\"\\"\ndone\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In order to run commands, you would run the script and then the command right after. For example: ",(0,a.jsx)(n.code,{children:'bash script.sh "./bin/solr create_core -c breach"'}),". If you were using Kubernetes instead of MicroK8s, you would remove ",(0,a.jsx)(n.code,{children:"microk8s"})," from the script."]}),"\n",(0,a.jsx)(n.h4,{id:"setup",children:"Setup"}),"\n",(0,a.jsx)(n.p,{children:"The following are the commands that I used to setup the Solr system."}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Just to note after installing ",(0,a.jsx)(n.code,{children:"microk8s"}),", if you reboot, you will not have to run ",(0,a.jsx)(n.code,{children:"snap run microk8s"})," each time and can run it directly as ",(0,a.jsx)(n.code,{children:"microk8s"}),". Only for taking down the infrastructure will you need to run ",(0,a.jsx)(n.code,{children:"snap run."})]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# MicroK8s\n#Install snapd\nsudo apt install snapd ufw -y\n# Install MicroK8s\nsudo snap install microk8s --classic\n# Allow firewall rules\nsudo ufw allow in on cni0 && sudo ufw allow out on cni0\nsudo ufw default allow routed\n# Fix permissions so you can run commands\nsudo usermod -a -G microk8s user\nsudo chown -R user ~/.kube\nnewgrp microk8s\n# Start MicroK8s\nsnap run microk8s start\n# Enable Add-ons\nsnap run microk8s enable dns \nsnap run microk8s enable dashboard\nsnap run microk8s enable storage #storage is deprecated, `hostpath-storage` should be used\n# Run this in another terminal; Access the URL and token for Kubernetes dashboard; \nsnap run microk8s dashboard-proxy\n# Apply all yaml files from breach folder\nsnap run microk8s kubectl apply -f ./breach-YAML\n# Create a core (index) called breach - this will create a core on all pods\nbash script.sh "./bin/solr create_core -c breach"\n# You then push the breach data to all of the pods as well: \nbash script.sh "./bin/solr post -c breach /opt/solr/server/solr/mydata/MOCK_DATA.csv"\n## After this all the nodes have it and the load balancer IP will not have any issues since they all have the data setup.\n## Check the load balancer to make sure no errors are showing up in searches (by running it 10-20 times)\n\n# Cleanup\n## Delete the deployment\nsnap run microk8s kubectl delete deployment solr-deployment\n## Reset MicroK8s in case you need to use it for another project\nsudo snap run microk8s reset\n## Stop MicroK8s\nsudo snap run microk8s stop\n'})}),"\n",(0,a.jsx)(n.h2,{id:"general-recommendations",children:"General Recommendations"}),"\n",(0,a.jsx)(n.p,{children:'My recommendation for when to use what "container" depends on the situation. If you are a hobbyist, I would recommend using a virtual machine. It is straight-forward to setup, and you don\'t have to worry about learning a whole new technology or mitigating container issues. Virtual Machines (if you do not connect the from VM to host) allow you to segment the files in the virtual machine, preventing potential malware (to a high extent) from getting on to your host machine. If you want something a bit lightweight, then I can recommend Podman or Docker. These are lighter than virtual machines and take less work to setup than virtual machines when it comes to applications. However, with containers you have to understand how ports, volumes, etc. work in order to get your application in a state you want it. Finally, Kubernetes (by itself, and at a MicroK8s-level - including minikube, Kind, etc.) is what I would recommend for a team of users and for corporate environments. This is great for load balancing and high availability for your applications, and a hobbyist will most likely not deal with load or availability issues. If your team is leveraging Docker already, then Docker Swarm might be a better fit for you.'}),"\n",(0,a.jsx)(n.h2,{id:"errors",children:"Errors"}),"\n",(0,a.jsx)(n.p,{children:"I ran into a lot of errors trying to setup minikube and Kind. MicroK8s ended up working for me, but I still wanted to share the errors I had encountered:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Ran into an issue where minikube was having trouble running with Podman in the runtime container mentioned on ",(0,a.jsx)(n.a,{href:"https://minikube.sigs.k8s.io/docs/drivers/podman/",children:"https://minikube.sigs.k8s.io/docs/drivers/podman/"}),". To mitigate this error, I  then switched from Podman to Docker to continue working on this blog. This still did not resolve anything"]}),"\n",(0,a.jsx)(n.li,{children:"Docker rootless and Docker root-full led to me having the same error: When I SSH into the pod, it asks me if the Docker daemon is running...which minikube should have taken care of when initializing"}),"\n",(0,a.jsx)(n.li,{children:"With Kind I couldn't add Docker images from Docker Hub. I was limited to local images only"}),"\n",(0,a.jsx)(n.li,{children:"minikube with Docker was running into issues of misconfiguration, without me tweaking any settings. It worked once, but then it just stopped after"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"I used this blog as an excuse to play around with Kubernetes, as I wanted to see how container orchestration can be used for bigger breach data environments. I spent a lot of time trying out Kubernetes at a small scale with minikube and then Kind (for a little bit). MicroK8s just seem to have an easy setup, and had a more friendly tutorial to go with it. No driver configuration or anything needed. All that to say, I did learn a lot of Kubernetes while writing this blog. I would definitely recommend MicroK8s and Kubernetes to those who have higher loads and need high availability for their breach environments. I do hope my setup is beneficial to others in a similar situation."}),"\n",(0,a.jsx)(n.h2,{id:"sources",children:"Sources"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://aws.amazon.com/compare/the-difference-between-type-1-and-type-2-hypervisors/",children:"https://aws.amazon.com/compare/the-difference-between-type-1-and-type-2-hypervisors/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.gnu.org/software/bash/manual/bash.html#What-is-a-shell%5C_003f",children:"https://www.gnu.org/software/bash/manual/bash.html#What-is-a-shell\\_003f"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.redhat.com/en/topics/containers/what-is-podman",children:"https://www.redhat.com/en/topics/containers/what-is-podman"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/containers/podman/blob/main/docs/tutorials/rootless%5C_tutorial.md",children:"https://github.com/containers/podman/blob/main/docs/tutorials/rootless\\_tutorial.md"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://stackoverflow.com/a/52027977",children:"https://stackoverflow.com/a/52027977"})," or ",(0,a.jsx)(n.a,{href:"https://stackoverflow.com/questions/52024961/difference-between-minikube-kubernetes-docker-compose-docker-swarm-etc",children:"https://stackoverflow.com/questions/52024961/difference-between-minikube-kubernetes-docker-compose-docker-swarm-etc"})]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://stackshare.io/stackups/kubernetes-vs-minikube",children:"https://stackshare.io/stackups/kubernetes-vs-minikube"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://askubuntu.com/questions/40011/how-to-let-dpkg-i-install-dependencies-for-me",children:"https://askubuntu.com/questions/40011/how-to-let-dpkg-i-install-dependencies-for-me"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://kubernetes.io/docs/tutorials/hello-minikube/",children:"https://kubernetes.io/docs/tutorials/hello-minikube/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://dev.to/donhadley22/deploying-a-simple-application-in-a-container-with-minikube-in-a-docker-runtime-3en8",children:"https://dev.to/donhadley22/deploying-a-simple-application-in-a-container-with-minikube-in-a-docker-runtime-3en8"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://adamtheautomator.com/apache-solr-tutorials/",children:"https://adamtheautomator.com/apache-solr-tutorials/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://stackoverflow.com/questions/61144060/minikube-driver-podman-has-anyone-been-able-to-get-it-to-work",children:"https://stackoverflow.com/questions/61144060/minikube-driver-podman-has-anyone-been-able-to-get-it-to-work"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://minikube.sigs.k8s.io/docs/drivers/podman/",children:"https://minikube.sigs.k8s.io/docs/drivers/podman/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/",children:"https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://iximiuz.com/en/posts/kubernetes-kind-load-docker-image/",children:"https://iximiuz.com/en/posts/kubernetes-kind-load-docker-image/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/",children:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/",children:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://k8syaml.com/",children:"https://k8syaml.com/"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://chatgpt.com",children:"https://chatgpt.com"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},6171:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/Screenshot_2024-07-07_11-23.cleaned-6f51f475e1ba1d84c9990a6dd008685e.png"},7700:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/Screenshot_2024-07-07_11-23_1.cleaned-980c7966824fcbc06b951c8124455768.png"},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(6540);const a={},i=o.createContext(a);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);